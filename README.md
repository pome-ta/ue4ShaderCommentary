# ue4ShaderCommentary


いつも、手元にUnreal Engine があるとは限らないので、テキストエディタで表現できる書き方を定義してみます 😇<br>
ノード(関数)と、ピン、ワイヤーを、文字で表現してみる試みちゃ☆

> 複雑なことを書かないと思うので、便宜的に(ワイちゃんオリジナル)



## 表記例

``` .hs
[<in: ピン> "ノード(関数)名" <out: ピン>]

```



### 具体例

``` .hs
[ "TexCoord" <(r, g)>] -> [<final_color: (r, g)> "最終出力"]
```

![画像例](https://docs.unrealengine.com/Images/RenderingAndGraphics/Materials/ExpressionReference/Coordinates/TextureCoordinateExample.jpg)

↑は、Texture を表示してるけど、UV だけで出せる([後述](#))

> [公式リファレンス(texturecoordinate)](https://docs.unrealengine.com/ja/RenderingAndGraphics/Materials/ExpressionReference/Coordinates/index.html#texturecoordinate)

マテリアルの設定で`UserInterface` にする。


ピンの`in` ,`out` の名前で繋ぐ的な、ワイヤーの表現をしてる

この場合だと、`TexCoord` の`out` にあるピンは、2つの値がある(`r = U` , `g = V` )

`最終出力` の`final_color` は、`R,G,B` 値を受け取れる。`r = R` ,`g = G` を`TexCoord` の数値から貰ってくる

> SyntaxHighlight 上、`in` `out` の名前で間にスペースがあるものは、`_` で繋いでる(スネークケース)









## 色を出力する


### 単色

[具体例](#具体例)のノードは、忘れるんだ😇 ただ、ノードの繋ぎ方をテキストで表現した説明なのだ😊


基礎の基礎から始める。まずは、単色の出力

`RGB` で色を表現できるので「赤、緑、青」は比較的扱いやすいので出力する。


#### 赤

``` .hs
[<R: 1.0, G: 0.0, B: 0.0> "Constant3Vector" <out: (R, G, B)>] -> [<final_color: (R, G, B)> "最終出力"]
```

> [公式リファレンス(Constant3Vector)](https://docs.unrealengine.com/ja/RenderingAndGraphics/Materials/ExpressionReference/Constant/index.html#constant3vector)


`TexCoord` 使うと思った？まだ、早いぞ 😇

なお、`Constant3Vector` のショートカットは、`3` 


赤色が出力されている(はず)だから、残りの2色も行ってみよー！(本機で挙動確認ができないのです。なので動かなかったスマン)


##### 他のアプローチ


リファレンス検索して見つからなくて、(私が)前に使ったはずの[`Make Vector`](https://docs.unrealengine.com/en-US/BlueprintAPI/Math/Vector/MakeVector/index.html) 的なやつのマテリアルエディタで使えるやつ？での実装もできる


`make float3` とかだったか？(なんせ、全然リファレンスが上手に探せない。。。)


やり方、考え方は同じで


``` .hs
[ "Constant" <R(とする): 1.0>] ->
[ "Constant" <G(とする): 0.0>] ->
[ "Constant" <B(とする): 0.0>] -> [<R, G, B> "make_float3(的なの)" <rgb: (R, G, B)>] -> [<final_color: (R, G, B)> "最終出力"]
```

このような感じで、単体ごとに色を指定し`make_vector(的なの)` で、出口を一つにする(「出口を一つ」は、[後述](#))



#### 原色以外の色

説明不要だと思うけど、`R`, `G`, `B` の数値を`0.0 ~ 1.0` 内で指定すれば表現できる

- `R: 1.0, G: 0.5, B: 0.0`
- `R: 0.0, G: 0.5, B: 0.0`
- `R: 1.0, G: 0.0, B: 1.0`
- `R: 0.5, G: 0.5, B: 1.0`

など、、、

あと以下もはずせない

- `R: 0.0, G: 0.0, B: 0.0`
- `R: 1.0, G: 1.0, B: 1.0`


え？`1.0` 以上だとどうなるか？だって？

うむ。君の手で実装し、君の目で結果を刮目せよ 😇

いい質問だ、精進するのだ


## 色が出力されるということ

`TexCoord` だと、グラデーションで出力されるのに、今回は全面単色。何故なのか？

ここでやっと(フラグメント(ピクセル))シェーダーの考え方が必要になってくる



3 x 3 のマス目があるとする(`.0` は、`0.0`。`.5` は、`0.5`)

```
(x: よこ, y: たて) = 座標

             |              |
(  .0, .0  ) | (  .5, .0  ) | (  1., .0  )
             |              |
-------------|--------------|-------------
             |              |
(  .0, .5  ) | (  .5, .5  ) | (  1., .5  )
             |              |
-------------|--------------|-------------
             |              |
(  .0, 1.  ) | (  .5, 1.  ) | (  1., 1.  )
             |              |
             |              |

```

### 単色赤の場合

<b>座標</b>上、全部を「赤」にすればいいので

```
(r, g, b) = RGBカラー

             |              |
(1., .0, .0) | (1., .0, .0) | (1., .0, .0)
             |              |
-------------|--------------|-------------
             |              |
(1., .0, .0) | (1., .0, .0) | (1., .0, .0)
             |              |
-------------|--------------|-------------
             |              |
(1., .0, .0) | (1., .0, .0) | (1., .0, .0)
             |              |
             |              |
```

これで、済む



### 仕組みとして

単色の場合、`Constant` で数値を指定した。指定した数値を変えたら全部の色が変わった

つまり、<b>座標</b>上の全てを指定した


先に結果から言うと

`TexCoord` は、座標の<b>一つ一つ</b>を指定できる仕組みなのだ 😊



## シェーダーというか、並列処理というか、GPU というか、3DCG というか


人間の頭は、(多分)シングルタスクなので、順を追って説明をすると、、、



3 x 3 の場合

1. 「描画しますよー 🤗」と、指示が来る
1. 最初の`(0.0, 0.0)` に塗るための色の指示を探す
1. `RGB`値 の指示を受け取り`(0.0, 0.0)` に着色
1. 次の`(0.5, 0.0)` に塗るための色の指示を探す
1. `RGB`値 の指示を受け取り`(0.5, 0.0)` に着色
1. (中略)
1. 最後の`(1.0, 1.0)` に塗るための色の指示を探す
1. `RGB`値 の指示を受け取り`(1.0, 1.0)` に着色
1. 全マス「着色できますた 😭」と報告あり
1. 描画される


シェーダー処理は、「指示」と「報告」の間の手順を一括で処理をする


考え方的に難しいのが、この「一括処理」の部分だと(ワイ)は考えている


`Constant` の`1.0` は、「`1.0`」という<b>ひとつ</b>の数値ではなく、「`1.0`, `1.0`, `1.0`」という数値なのですす(3 x 3の場合)


`TexCoord` の数値は、`U` が「`0.0`, `0.5`, `1.0`」`V` が「`0.0`, `0.5`, `1.0`」を持っており

それぞれの組み合わせ(座標の(x, y)) に振られていくのです


これ(再掲)

```
(x: よこ, y: たて) = 座標

             |              |
(  .0, .0  ) | (  .5, .0  ) | (  1., .0  )
             |              |
-------------|--------------|-------------
             |              |
(  .0, .5  ) | (  .5, .5  ) | (  1., .5  )
             |              |
-------------|--------------|-------------
             |              |
(  .0, 1.  ) | (  .5, 1.  ) | (  1., 1.  )
             |              |
             |              |

```


### つらい、、つらい、、

つらい。なんでつらいのか？


それは「気がついたら、<b>数値</b>が他の意味の数値に変わってる」から(ん？ちょっと違うかもスマン)



「`x` 軸のことを考えていたら、色指定のことを忘れていた or 考える必要があった」

「色が変わるということは、座標的にどうなるのだ？」

「`time` で取得した数値は、色？位置？」

「なんか、できた」


あるあるである。


#### 脱線(愚痴)

そもそものところ、シェーダープログラミング(ノードであっても)は、ほかのプログラミングよりも難しい(言い切ってしまうと`C++` よりも)


一般的なプログラミングは、シェーダーが描画される手順をひとつひとつ行う。シェーダープログラムは、一気にやる<b>狂ってる</b>。


しかも、3DCG プログラムは`RGB` の数値(色)を`XYZ` の空間座標に置き換える。とかを普通？常識よ？のような顔でやる<b>狂気の沙汰</b>である。


我々凡人は、そのアーキテクチャを考えた狂人の肩を借りているのだから<b>使いこなせる訳がない</b>



描画の仕組みを理解した上で、トライアンドエラーを繰り返して、脳筋を鍛えるしかない



## 色を動かす


単色が出せたということは、やっと0次元に立てましたー！ 🎉

まだまだ、`TexCoord` は使わせないぞー 😊


1次元にするために、`x`, `y` 軸でなくて、時間を使っていきます


### `time` と`sine` と `abs`


``` .hs
[ "Time" <out: time>] -> [<final_color: time> "最終出力"]
```

なんか、出ると思ったでしょ？

残念でしたー！真っ白(の、はず)でーす 😩


理由より先に、色を出します



``` .hs
[ "Time" <out: time>] -> [<in: time > "sine" <out: sine>] -> [<in: sine> "Abs" <out: abs>] -> [<final_color: abs> "最終出力"]
```

白黒で、チカチカした？(してくれないと困る)


次に、2つの派生系を考えていきたい


- チカチカする速さを変える
- 他の色でチカチカさせたい

関数のノードも使い始めたので、速度を変えることから


#### 点滅の速さを変える


コードを見ていく(見辛いから、改行しているけど、上と同じ)

``` .hs
[ "Time" <out: time>]
-> [<in: time > "sine" <out: sine>] -> [<in: sine> "Abs" <out: abs>]
-> [<final_color: abs> "最終出力"]
```


`Time`(リファレンス見つからない)

説明せんでも、わかるやろ？ 😇


[`Sine`](https://docs.unrealengine.com/ja/RenderingAndGraphics/Materials/ExpressionReference/Math/index.html#Sine)

リファレンスの本文で、読み解くところは
> Sine 式は、[0、1] の入力範囲と [-1、1] の出力範囲にサイン波の値繰り返し出力します。

ここと、
> 出力範囲は [0、1] に調整しています。

あと、画像を見ておけばいい。


![画像](https://docs.unrealengine.com/Images/RenderingAndGraphics/Materials/ExpressionReference/Math/SineWave.webp)

`Cosine` 実行してみてもいいけど、今回のノードの組み合わせだと変化を感じないと思うで

[`Abs`](https://docs.unrealengine.com/ja/RenderingAndGraphics/Materials/ExpressionReference/Math/index.html#abs)

読み解くところは

> 、基本的にマイナス符号を取り除くことで負の数を正の数に変えます。正の数と 0 の場合は変化しません。
> 例： -0.7 の Abs は 0.7 、-1.0 の Abs は 1.0、1.0 の Abs は 1.0 です。











---

# メモ


ue の関数から探すのではなく、やりたいことをue の関数から探してる


[`TimeWithSpeedVariable`](https://docs.unrealengine.たcom/ja/RenderingAndGraphics/Materials/Functions/Reference/Misc/index.html#TimeWithSpeedVariable)

`time` に`Frac` なんていらなかったんや、、、

`SplitComponents`
